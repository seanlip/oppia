// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Component for a set of audio controls for a specific
 * audio translation in the learner view.
 */

import {Component} from '@angular/core';
import {Voiceover} from 'domain/exploration/voiceover.model';
import {Subscription} from 'rxjs';
import {AssetsBackendApiService} from 'services/assets-backend-api.service';
import {AudioBarStatusService} from 'services/audio-bar-status.service';
import {
  AudioPlayerService,
  AutoPlayAudioEvent,
} from 'services/audio-player.service';
import {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';
import {ContextService} from 'services/context.service';
import {SiteAnalyticsService} from 'services/site-analytics.service';
import {AudioPreloaderService} from '../services/audio-preloader.service';
import {
  AudioTranslationLanguageService,
  ExplorationLanguageInfo,
} from '../services/audio-translation-language.service';
import {PlayerPositionService} from '../services/player-position.service';
import {I18nLanguageCodeService} from 'services/i18n-language-code.service';
import {EntityVoiceoversService} from 'services/entity-voiceovers.services';
import {PlatformFeatureService} from 'services/platform-feature.service';
import {VoiceoverPlayerService} from '../services/voiceover-player.service';
import {LanguageAccentToDescription} from 'domain/voiceover/voiceover-backend-api.service';
import {LocalStorageService} from 'services/local-storage.service';

@Component({
  selector: 'oppia-audio-bar',
  templateUrl: './audio-bar.component.html',
})
export class AudioBarComponent {
  lastScrollTop: number = 0;
  isPaused: boolean = true;
  directiveSubscriptions: Subscription = new Subscription();
  languagesInExploration: ExplorationLanguageInfo[];
  audioBarIsExpanded: boolean = false;
  progressBarIsShown: boolean = false;
  audioLoadingIndicatorIsShown: boolean = false;
  explorationPlayerModeIsActive: boolean;
  // Value may be null if the language is not available.
  selectedLanguage: {value: string | null};
  languageAccentCodesToDescriptions!: LanguageAccentToDescription;
  languageAccentDecriptions: string[] = [];
  selectedLanguageAccentDescription!: string;
  voiceoverToBePlayed!: Voiceover | undefined;
  currentVoiceoverTime: number = 0;

  constructor(
    private assetsBackendApiService: AssetsBackendApiService,
    private audioBarStatusService: AudioBarStatusService,
    private audioPlayerService: AudioPlayerService,
    private audioPreloaderService: AudioPreloaderService,
    private audioTranslationLanguageService: AudioTranslationLanguageService,
    private autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService,
    private contextService: ContextService,
    private playerPositionService: PlayerPositionService,
    private I18nLanguageCodeService: I18nLanguageCodeService,
    private siteAnalyticsService: SiteAnalyticsService,
    private entityVoiceoversService: EntityVoiceoversService,
    private platformFeatureService: PlatformFeatureService,
    private voiceoverPlayerService: VoiceoverPlayerService,
    private localStorageService: LocalStorageService
  ) {
    this.explorationPlayerModeIsActive =
      this.contextService.isInExplorationPlayerPage();
    this.languagesInExploration =
      this.audioTranslationLanguageService.getLanguageOptionsForDropdown();
    this.selectedLanguage = {
      value: this.getCurrentAudioLanguageCode(),
    };
  }

  ngOnInit(): void {
    this.directiveSubscriptions.add(
      this.voiceoverPlayerService.onTranslationLanguageChanged.subscribe(() => {
        this.audioPlayerService.stop();
        this.audioPlayerService.clear();
        this.voiceoverToBePlayed = undefined;
        this.setProgress({value: 0});
        this.updateDisplayableLanguageAccentDescription();
      })
    );

    this.directiveSubscriptions.add(
      this.voiceoverPlayerService.onActiveVoiceoverChanged.subscribe(() => {
        this.voiceoverToBePlayed =
          this.voiceoverPlayerService.getActiveVoiceover() as Voiceover;
      })
    );

    this.directiveSubscriptions.add(
      this.audioPlayerService.onAutoplayAudio.subscribe(
        (params: AutoPlayAudioEvent) => {
          if (this.audioBarIsExpanded) {
            this.audioPlayerService.stop();
            this.autogeneratedAudioPlayerService.cancel();
          }
        }
      )
    );
    this.audioBarIsExpanded = false;
    this.progressBarIsShown = false;
    this.audioLoadingIndicatorIsShown = false;
    this.audioPreloaderService.setAudioLoadedCallback(
      this.onFinishedLoadingAudio.bind(this)
    );

    this.languageAccentDecriptions =
      this.voiceoverPlayerService.getLanguageAccentDescriptions();
  }

  ngOnDestroy(): void {
    this.directiveSubscriptions.unsubscribe();
  }

  ngAfterContentChecked(): void {
    this.currentVoiceoverTime = this.audioPlayerService.getCurrentTime();
  }

  setProgress(val: {value: number}): void {
    this.audioPlayerService.setCurrentTime(val.value);
  }

  isAudioBarAvailable(): boolean {
    return this.languageAccentDecriptions.length > 0;
  }

  isLanguageRTL(): boolean {
    return this.I18nLanguageCodeService.isCurrentLanguageRTL();
  }

  expandAudioBar(): void {
    this.audioBarIsExpanded = true;
    this.audioBarStatusService.markAudioBarExpanded();
  }

  collapseAudioBar(): void {
    this.audioBarStatusService.markAudioBarCollapsed();
    this.audioBarIsExpanded = false;
    this.audioPlayerService.stop();
    this.audioPlayerService.clear();
    this.autogeneratedAudioPlayerService.cancel();
  }

  // Returns null if the audio is not available in the current language.
  getCurrentAudioLanguageCode(): string | null {
    return this.audioTranslationLanguageService.getCurrentAudioLanguageCode();
  }

  // Returns null if the audio is not available in the current language.
  getCurrentAudioLanguageDescription(): string | null {
    return this.audioTranslationLanguageService.getCurrentAudioLanguageDescription();
  }

  isAudioPlaying(): boolean {
    return (
      this.audioPlayerService.isPlaying() ||
      this.autogeneratedAudioPlayerService.isPlaying()
    );
  }

  isAudioAvailableInCurrentLanguage(): boolean {
    return this.voiceoverToBePlayed !== undefined;
  }

  doesCurrentAudioTranslationNeedUpdate(): boolean {
    if (this.voiceoverToBePlayed !== undefined) {
      return this.voiceoverToBePlayed.needsUpdate;
    }
    return false;
  }

  isAutogeneratedLanguageCodeSelected(): boolean {
    return this.audioTranslationLanguageService.isAutogeneratedLanguageCodeSelected();
  }

  onBackwardButtonClicked(): void {
    this.audioPlayerService.rewind(5);
  }

  onForwardButtonClicked(): void {
    this.audioPlayerService.forward(5);
  }

  updateDisplayableLanguageAccentDescription(): void {
    this.languageAccentDecriptions =
      this.voiceoverPlayerService.getLanguageAccentDescriptions();

    if (this.languageAccentDecriptions.length > 0) {
      this.selectedLanguageAccentDescription =
        this.languageAccentDecriptions[0];
      this.updateSelectedLanguageAccent();
    }
  }

  updateSelectedLanguageAccent(): void {
    this.audioPlayerService.stop();
    this.audioPlayerService.clear();
    this.setProgress({value: 0});
    let languageAccentCode =
      this.voiceoverPlayerService.languageAccentDescriptionsToCodes[
        this.selectedLanguageAccentDescription as string
      ];
    this.entityVoiceoversService.setActiveLanguageAccentCode(
      languageAccentCode
    );
    let entityVoiceover =
      this.entityVoiceoversService.getActiveEntityVoiceovers();

    let contentId = this.voiceoverPlayerService.activeContentId;

    this.voiceoverToBePlayed = entityVoiceover.getManualVoiceover(
      contentId
    ) as Voiceover;

    this.audioPreloaderService.restartAudioPreloader(
      this.playerPositionService.getCurrentStateName()
    );
  }

  onPlayButtonClicked(): void {
    this.isPaused = !this.isPaused;

    if (this.voiceoverToBePlayed) {
      this.playPauseUploadedAudioTranslation();
    }
    this.siteAnalyticsService.registerStartAudioPlayedEvent(
      this.contextService.getExplorationId(),
      this.playerPositionService.getDisplayedCardIndex()
    );
  }

  isCached(audioTranslation: Voiceover): boolean {
    return this.assetsBackendApiService.isCached(audioTranslation.filename);
  }

  playPauseUploadedAudioTranslation(): void {
    if (!this.audioPlayerService.isPlaying()) {
      if (this.audioPlayerService.isTrackLoaded()) {
        this.audioPlayerService.play();
      } else {
        this.loadAndPlayAudioTranslation();
      }
    } else {
      this.audioPlayerService.pause();
    }
  }

  playCachedAudioTranslation(audioFilename: string): void {
    this.audioPlayerService.loadAsync(audioFilename).then(() => {
      this.audioLoadingIndicatorIsShown = false;
      this.audioPlayerService.play();
    });
  }

  /**
   * Called when an audio file finishes loading.
   * @param {string} audioFilename - Filename of the audio file that
   *                                 finished loading.
   */
  onFinishedLoadingAudio(audioFilename: string): void {
    let mostRecentlyRequestedAudioFilename =
      this.audioPreloaderService.getMostRecentlyRequestedAudioFilename();
    if (
      this.audioLoadingIndicatorIsShown &&
      audioFilename === mostRecentlyRequestedAudioFilename
    ) {
      this.playCachedAudioTranslation(audioFilename);
    }
  }

  loadAndPlayAudioTranslation(): void {
    this.audioLoadingIndicatorIsShown = true;
    let audioTranslation = this.voiceoverToBePlayed;

    if (audioTranslation) {
      this.audioPreloaderService.setMostRecentlyRequestedAudioFilename(
        audioTranslation.filename
      );
      if (this.isCached(audioTranslation)) {
        this.playCachedAudioTranslation(audioTranslation.filename);
      } else if (
        !this.audioPreloaderService.isLoadingAudioFile(
          audioTranslation.filename
        )
      ) {
        this.audioPreloaderService.restartAudioPreloader(
          this.playerPositionService.getCurrentStateName()
        );
      }
    }
  }
}
